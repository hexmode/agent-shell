#+TITLE: Emacs Agent Shell
#+AUTHOR: Álvaro Ramírez

[[file:agent-shell.png]]

* This project needs your funding

As you pay for those useful LLM tokens, consider [[https://github.com/sponsors/xenodium][sponsoring]] development and maintenance of this project.

=agent-shell= is in its infancy. It's got rough edges and lots of features to implement still. With your help, I can make this effort more [[https://github.com/sponsors/xenodium][sustainable]].

Thank you!

[[https://xenodium.com/][Alvaro]]

* agent-shell

A native Emacs shell to interact with LLM agents powered by ACP ([[https://agentclientprotocol.com][Agent Client Protocol]]).

With agent-shell, you can chat with the likes of Gemini CLI, Claude Code, or any other ACP-driven agent.

*Note:* This package is in the very early stages and is likely incomplete or may have some rough edges.

* Related projects

- [[https://github.com/xenodium/acp.el][acp.el]]: An ACP (Agent Client Protocol) implementation in Emacs lisp.
- [[https://github.com/cmacrae/agent-shell-sidebar][agent-shell-sidebar]]: Emacs sidebar addon for agent-shell.

* Setup

** External dependencies

*** Claude Code

For Anthropic's Claude Code, follow [[https://github.com/zed-industries/claude-code-acp][Zed's claude-code-acp instructions]], typically something like:

#+begin_src bash
npm install -g @zed-industries/claude-code-acp
#+end_src

*Note:* The =-g= flag is required to install the binary globally so it's available in your PATH. After installation, verify it's available by running =which claude-code-acp= in your terminal.

*** Codex

For OpenAI's Codex, install [[https://github.com/zed-industries/codex-acp][zed/codex-acp]] and ensure the `codex-acp` executable is in PATH.

*** Gemini CLI

For Google's [[https://github.com/google-gemini/gemini-cli][Gemini CLI]], be sure to get a recent release supporting the =--experimental-acp= flag.

*** Goose

For Goose CLI, install [[https://block.github.io/goose/docs/getting-started/installation][goose]] and ensure the `goose` executable is in PATH.

*** Qwen Code

For Qwen Code, install with:

#+begin_src bash
npm install -g @qwen-code/qwen-code@latest
#+end_src

See https://github.com/QwenLM/qwen-code for details.

** Installation

=agent-shell= is powered by built-in =comint-shell=, via [[https://github.com/xenodium/shell-maker][shell-maker]], available on [[https://melpa.org/#/shell-maker][MELPA]].

You can install =shell-maker= via:

#+begin_src emacs-lisp
  (use-package shell-maker
    :ensure t)
#+end_src

=agent-shell= also depends on [[https://github.com/xenodium/acp.el][acp.el]], which isn't yet on MELPA. You can install with:

#+begin_src emacs-lisp
  (use-package acp
    :vc (:url "https://github.com/xenodium/acp.el"))
#+end_src

If you run into an error like =use-package: Keyword :vc received unknown argument=, ensure you're using the built-in =:vc= syntax shown above. Earlier guides relied on the external [[https://github.com/slotThe/vc-use-package][vc-use-package]] extension, which accepted =:fetcher=/:repo= keywords, but Emacs 30+ expects ELPA-style specs such as =:url=.

Finally, install =agent-shell= with:

#+begin_src emacs-lisp
  (use-package agent-shell
    :vc (:url "https://github.com/xenodium/agent-shell"))
#+end_src

*** Doom Emacs

If you are using Doom Emacs and would like to use the =package!= macro:

#+begin_src emacs-lisp
(package! shell-maker)
(package! acp :recipe (:host github :repo "xenodium/acp.el"))
(package! agent-shell :recipe (:host github :repo "xenodium/agent-shell"))
#+end_src

Run =doom sync= and restart.

Include =require= before configuration:

#+begin_src emacs-lisp
(require 'acp)
(require 'agent-shell)
;; rest of config...
#+end_src

** Configuration

Configure authentication for the agent providers you want to use.

*** Environment variables

Pass environment variables to the spawned agent process by customizing the `agent-shell-*-environment` variable with `agent-shell-make-environment-variables`. The helper accepts key/value pairs and exports them when the agent starts.

#+begin_src emacs-lisp
(setq agent-shell-anthropic-claude-environment
      (agent-shell-make-environment-variables
       "ANTHROPIC_API_KEY" (auth-source-pass-get "secret" "anthropic-api-key")
       "HTTPS_PROXY" "http://proxy.example.com:8080"))
#+end_src

**** Inheriting environment variables

By default, the agent process starts with a minimal environment. To inherit environment variables from the parent Emacs process, use the `:inherit-env t` parameter in `agent-shell-make-environment-variables`:

#+begin_src emacs-lisp
  (setenv "ANTHROPIC_API_KEY" (auth-source-pass-get "secret" "anthropic-api-key"))

  (setq agent-shell-anthropic-claude-environment
        (agent-shell-make-environment-variables :inherit-env t))
#+end_src

This ensures that environment variables like `PATH`, `HOME`, and others from your Emacs session are available to the agent process, while still allowing you to override or add specific variables.

**** Loading environment variables from files

You can load environment variables from .env files using the `:load-env` parameter. This supports both single and multiple files:

#+begin_src emacs-lisp
  ;; Load from a single .env file
  (setq agent-shell-anthropic-claude-environment
        (agent-shell-make-environment-variables
         :load-env "~/.env"
         "CUSTOM_VAR" "custom_value"))

  ;; Load from multiple .env files
  (setq agent-shell-anthropic-claude-environment
        (agent-shell-make-environment-variables
         :load-env '("~/.env" ".env.local")
         :inherit-env t))
#+end_src

The .env files should contain variables in the format `KEY=value`, with one variable per line. Comments (lines starting with `#`) and empty lines are ignored.

*** Anthropic Claude

For login-based authentication (default):

#+begin_src emacs-lisp
(setq agent-shell-anthropic-authentication
      (agent-shell-anthropic-make-authentication :login t))
#+end_src

For API key authentication:

#+begin_src emacs-lisp
;; With string
(setq agent-shell-anthropic-authentication
      (agent-shell-anthropic-make-authentication :api-key "your-anthropic-api-key-here"))

;; With function
(setq agent-shell-anthropic-authentication
      (agent-shell-anthropic-make-authentication
       :api-key (lambda () (auth-source-pass-get "secret" "anthropic-api-key"))))
#+end_src

For alternative Anthropic-compatible API endpoints, configure via environment variables:

#+begin_src emacs-lisp
  (setq agent-shell-anthropic-claude-environment
        (agent-shell-make-environment-variables
         "ANTHROPIC_BASE_URL" "https://api.moonshot.cn/anthropic"
         "ANTHROPIC_MODEL" "kimi-k2-turbo-preview"
         "ANTHROPIC_SMALL_FAST_MODEL" "kimi-k2-turbo-preview"))
#+end_src

*** Google Gemini

For login-based authentication (default):

#+begin_src emacs-lisp
(setq agent-shell-google-authentication
      (agent-shell-google-make-authentication :login t))
#+end_src

For API key authentication:

#+begin_src emacs-lisp
;; With string
(setq agent-shell-google-authentication
      (agent-shell-google-make-authentication :api-key "your-google-api-key-here"))

;; With function
(setq agent-shell-google-authentication
      (agent-shell-google-make-authentication
       :api-key (lambda () (auth-source-pass-get "secret" "google-api-key"))))
#+end_src

For Vertex AI authentication:

#+begin_src emacs-lisp
(setq agent-shell-google-authentication
      (agent-shell-google-make-authentication :vertex-ai t))
#+end_src

*** OpenAI Codex

For login-based authentication (default):

#+begin_src emacs-lisp
(setq agent-shell-openai-authentication
      (agent-shell-openai-make-authentication :login t))
#+end_src

For API key authentication:

#+begin_src emacs-lisp
;; With string
(setq agent-shell-openai-authentication
      (agent-shell-openai-make-authentication :api-key "your-openai-api-key-here"))

;; With function
(setq agent-shell-openai-authentication
      (agent-shell-openai-make-authentication
       :api-key (lambda () (auth-source-pass-get "secret" "openai-api-key"))))
#+end_src

*** Goose

For OpenAI API key authentication:

#+begin_src emacs-lisp
;; With string
(setq agent-shell-goose-authentication
      (agent-shell-make-goose-authentication :openai-api-key "your-openai-api-key-here"))

;; With function
(setq agent-shell-goose-authentication
      (agent-shell-make-goose-authentication
       :openai-api-key (lambda () (auth-source-pass-get "secret" "openai-api-key"))))
#+end_src

*** Qwen Code

For OAuth login-based authentication:

#+begin_src emacs-lisp
(setq agent-shell-qwen-authentication
      (agent-shell-qwen-make-authentication :login t))
#+end_src

*** Customizing Available Agents

By default, =agent-shell= includes configurations for all supported agents (Claude Code, Gemini CLI, Codex, Goose, and Qwen Code). You can customize which agents are available through the =agent-shell-agent-configs= variable.

** Usage

*** Quick Start

=M-x agent-shell= - Start or reuse any of the known agents.

You can select and start any of the known agent shells (see =agent-shell-agent-configs=) via the =agent-shell= interactive command and enables reusing existing shells when available. With a prefix argument (=C-u M-x agent-shell=), it forces starting a new shell session, thus instantiating multiple agent shells.

*** Specific Agent Commands

Start a specific agent shell session directly:

- =M-x agent-shell-anthropic-start-claude-code= - Start a Claude Code agent session
- =M-x agent-shell-openai-start-codex= - Start a Codex agent session
- =M-x agent-shell-google-start-gemini= - Start a Gemini agent session
- =M-x agent-shell-goose-start-agent= - Start a Goose agent session
- =M-x agent-shell-qwen-start= - Start a Qwen Code agent session

** Running agents in Devcontainers / Docker containers (Experimental)

=agent-shell= provides rudimentary support for running agents in containers.

Adapt the command that starts the agent so it is executed inside the container; for example:

#+begin_src emacs-lisp
(setq agent-shell-anthropic-claude-command '("devcontainer" "exec" "--workspace-folder" "." "claude-code-acp"))
#+end_src

Note that any =:environment-variables= you may have passed to =acp-make-client= will not apply to the agent process running inside the container.
It's expected to inject environment variables by means of your devcontainer configuration / Dockerfile.

Next, set an =agent-shell-path-resolver-function= that resolves container paths in the local working directory, and vice versa.
Agent shell provides the =agent-shell--resolve-devcontainer-path= function for use with devcontainers:

#+begin_src emacs-lisp
(setq agent-shell-path-resolver-function #'agent-shell--resolve-devcontainer-path)
#+end_src

Note that this allows the agent to access files on your local file-system.
While care has been taken to restrict access to files in the local working directory, it's probably possible for a malicious agent to circumvent this restriction.

Optional: to prevent the agent running inside the container to access your local file-system altogether and to have it read/modify files inside the container directly, in addition to setting the resolver function, disable the "read/write text file" client capabilities:

#+begin_src emacs-lisp
(setq agent-shell-text-file-capabilities nil)
#+end_src

All of the above settings can be applied on a per-project basis using [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html][directory-local variables]].

** Keybindings

- =C-c C-c= - Interrupt current agent operation
- =TAB and Shift-TAB= - Navigate interactive elements

* Contributing

** Before Contributing

Before implementing new features, please *file a feature request first* to discuss the proposal. This helps ensure alignment with the project's direction and prevents unnecessary work.

As the maintainer, I must be mindful of all features I accept since I inherit the code to maintain it. Some features may be better suited as separate packages (like [[https://github.com/cmacrae/agent-shell-sidebar][agent-shell-sidebar]]).

I'll gladly promote your package wherever possible.

** Style (or personal preference TBH)

There are lots of ways to accomplish things in elisp. While the following are merely personal preferences, as maintainer, it really simplifies things for me to try to limit the number of ways to accomplish things.

*** Maps (use alists)

This project relies on [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html][alists]] for much of its functionality. Sure, we can also use plists, hashtables, etc.

Unless we have a strong argument to use something else, please stick with =alists= (and =:= keywords).

#+begin_src emacs-lisp
  '((:species . "Cat")
    (:name . "Whiskers")
    (:age . 4)
    (:color . "Gray")
    (:favorite-toy . "Feather Wand"))
#+end_src

*** seq.el

Accessing and working with lists? Please prefer =seq.el=, unless we have a strong argument to use an alternative.

#+begin_src emacs-lisp :lexical no
  (setq animals
        (list
         '((:species . "Cat")
           (:name . "Whiskers")
           (:age . 4)
           (:color . "Gray"))
         '((:species . "Dog")
           (:name . "Buddy")
           (:age . 6)
           (:color . "Brown"))))

  (seq-first animals)
#+end_src

*** map.el

Accessing and working with =alists=? Please prefer =map.el= unless we have a strong argument to use an alternative.

#+begin_src emacs-lisp :lexical no
  (setq animal (seq-first animals))
  (map-elt animal :species)
#+end_src

*** cl-lib (limited to =cl-defun=)

While I'm a fan of =cl-defun=, please limit =cl= usage to =cl-defun= if possible. Nothing against =cl-lib=. I'm just limiting the surface and number of idioms I need to keep in my head to maintain the codebase. Often, =seq.el= and =map.el= can do the job just fine.

=cl-defun=, on the other hand, please do! I'm a fan of named parameters (yay for self-documenting), so use =&key= if possible.

#+begin_src emacs-lisp :lexical no
  (cl-defun describe (&key animal)
    "Describe an ANIMAL, which is an alist of properties like :species, :name, :age, :color."
    (message "This is a %d-year-old %s %s named %s."
             (map-elt animal :age 0)
             (map-elt animal :color "Unknown Color")
             (map-elt animal :species "Unknown Species")
             (map-elt animal :name "Unnamed")))

  (describe :animal '((:species . "Cat")
                      (:name . "Whiskers")
                      (:age . 4)
                      (:color . "Gray")))
#+end_src

*** Code/feature consistency

Please try to look for a similar feature in the code base and replicate an existing pattern usage if possible.

*** Code Checks

Before submitting a PR, please run:

- =M-x checkdoc= - Ensures documentation consistency
- =M-x byte-compile-file= - Identifies compilation warnings

*** Tests

I'm aware, we're a bit light on tests, but we started adding some tests. If adding a new feature, please try to add tests.

Tests live under the tests directory:

#+begin_src bash
  ls tests/*tests.el
#+end_src

#+RESULTS:
| tests/agent-shell-anthropic-tests.el |
| tests/agent-shell-tests.el           |

*** Running tests

Opening any file under the =tests= directory will load the =agent-shell-run-all-tests= command.

Run tests with =M-x agent-shell-run-all-tests=.

* Contributors

#+HTML: <a href="https://github.com/xenodium/agent-shell/graphs/contributors">
#+HTML:   <img src="https://contrib.rocks/image?repo=xenodium/agent-shell" />
#+HTML: </a>

Made with [[https://contrib.rocks][contrib.rocks]].
